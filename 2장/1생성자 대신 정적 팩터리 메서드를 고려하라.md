### ITEM 1   
생성자 대신 정적 팩터리 메서드를 고려하라
===

## 개요  
흔히 우리는 클래스의 인스터를 얻기 위하여 생성자를 사용한다.   
* 생성자를 활용한 인스턴스 생성
    
~~~
class character{
	
	int hp;
	int mp;
	
	character(int hp,int mp){
		hp=this.mp;
		hp=this.mp;
	}
}
~~~
팩터리 메서드를 사용하기에 앞서 팩터리 메서드란 무엇일까? 

클래스의 객체를 생성하는 메서드를 만들고 이를 static선언을 하여 만드는 것이다.

* 정적 팩터리 메서드를 활용한 인스턴스 생성
~~~
class character{
	
	int hp;
	int mp;
	
	character(int hp,int mp){
		hp=this.mp;
		hp=this.mp;
	}
	
	static character hp(int hp,int mp) {
		return new character(hp,mp);
	}
}
~~~

## 정적 팩터리 메서드의 장점
### 1. 이름을 가질 수 있다.
생성자는 무조건 클래스와 같은 이름을 가진다.  

하지만 메서드는 이름을 지어줄 수 있어 객체의 특성을 더 쉽게 묘사할 수 있다. 

~~~
public static void main(String[] args) {
		//매개변수의 값이 무슨 역할인지 이해하기 힘들며 특성을 잘 나타내지 못합니다.
		character ch1 = new character(5,5);
		//매개변수의 값이 hp와mp라는 것을 잘 나타냅니다.
		character ch2 = character.hp_mp(5, 5);
}
~~~

또한 생성자는 하나의 시그니처로는 하나의 생성자만을 만듭니다.

하지만 메서드는 이러한 제약이 없어 각각의 차이를 드러낼 수 있습니다.

~~~
static character warrior(int hp,int mp) {
		return new character(hp,mp);
}
	
static character magican(int hp,int mp) {
		return new character(hp,mp);
}
~~~
위의 두 메서드는 시그니처 제약이 없고 전사와 마법사를 만든다는 특성을 잘 표현해 준다.

### 2. 호출될 때마다 인스턴스를 새로 생성하지는 않아도 된다.
불필요한 객체 생성을 하는 것은 심한 메모리 낭비이다.   

만약 클래스의 멤버 변수가 1억개 라고 해보자.   

클래스의 객체를 자주 사용한다면 사용할 때마다 객체를 생성하여 1억 개의 대입 연산을 하게된다.

팩터리 메서드를 활용하여 인스턴스를 미리 만들어 놓고 메서드로 호출하여 불필요한 연산을 피할 수 있다.

~~~
class character{
	
	int hp;
	int mp;
	//master 인스턴스를 미리 생성한다.
	private static final character master = new character(50,50);
	
	character (int hp, int mp) {
		this.hp=hp;
		this.mp=mp;
	}
  // 만들어져 있는 master 인스턴스를 반환시켜준다.
	static character getmaster() {
		return master;
	}
	
}
~~~

