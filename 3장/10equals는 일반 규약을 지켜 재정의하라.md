### ITEM 10

## equals는 일반 규약을 지켜 재졍의하라

equals 메서드는 재정의 할때 따져 보야 할것이 많다. 
꼭 필요한 경우가 아니면 재정의하지 않는것이 바람직하다.

재정의하지 않아도 되는 경우

### 각 인스턴스가 본질적으로 고유하다.
값을 표현하는 게 아니라 동작하는 개체를 표편하는 클래스들이다. ex)Thread
인스턴스가 고유하기 때문에 같을 일이 없다.

### 인스턴스의 '논리적 동치성'을 검사할 일이 없다.
논리적 동치성이란 무엇일까?

equals를 통해 논리적 동치성을 확인할 필요가 없다면 굳이 재정의 하지 않아도 되며   
Object의 기본 equals로 해결된다.

### 상위 클래스에서 재정의한 equals가 하위 클래스에도 딱 들어맞는다.
상위 클래스의 equals를 문제없이 잘 사용한다면 재정의할 필요가 없다.

### 클래스가 private이거나 package-private이고 equals 메서드를 호출할 일이 없다.
클래스가 private으로 선언 되어 있다면(내부클래스?) equals를 사용할 일이 없다.

## equals를 재정의해야 할 때는 언제일까?

equals는 값을 가지는 클래스들끼리 비교해야 할 때이다.
객체가 같은지가 아니라 값이 같은지 이다. 

equals메서드를 재정의 할 때는 다음과 같은 규약을 따라야 한다.

### 반사성
null이 아닌 모든 참조값 x에 대하여 `x.equals(x)`는 true이다.
자기 자신은 자신과 같다? 나는나다?라는 표현이 저적할거다.
일부러 틀리기 어려워 보인다.
### 대칭성
null이 아닌 모든 참조가 x,y에 대해 x.equals(y)가 true면 y.equals(x)도 true이다.


